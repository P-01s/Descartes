#!/usr/bin/env ruby
# encoding: UTF-8
##
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
#                    Version 2, December 2004
# 
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long
# as the name is changed.
# 
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
#   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
# 
#  0. You just DO WHAT THE FUCK YOU WANT TO.
##

require 'descartes'
require 'optparse'
require 'fileutils'

options = {
  :nickname => 'Descartes',
  :server   => 'irc.rizon.net',
  :channels => ['#aggvistnurummor'],
  :dotfiles => File.join(ENV['HOME'], '.descartes'),
  :password => 'dat_password'
}

OptionParser.new { |o|
  o.on '-n', '--nickname NICKNAME', 'bot\'s nickname' do |nickname|
    options[:nickname] = nickname
  end

  o.on '-s', '--server SERVER', 'target IRC server' do |server|
    options[:server] = server
  end

  o.on '-c', '--channel #chan1,#chan2,#chan3', 'target channels' do |channels|
    options[:channels] = channels.split(?,).map { |s| s.strip }
  end

  o.on '-d', '--dotfiles PATH', 'folder where store config files' do |dotfiles|
    options[:dotfiles] = dotfiles
  end

  o.on '-p', '--password password', 'target channel\'s password' do |password|
    options[:password] = password
  end
}.parse!

unless File.directory? options[:dotfiles]
  files = File.join File.dirname(__FILE__), '../lib/descartes/modules/files'
  FileUtils.cp_r files, options[:dotfiles]
end

Cinch::Bot.new {
  configure do |c|
    c.nick     = options[:nickname]
    c.realname = 'Descartes'
    c.user     = 'Descartes'
    c.server   = options[:server]
    c.channels = options[:channels]
    
    c.plugins.plugins  = [Cinch::Plugins::Login] + Descartes.load(options)
    c.plugins.options[Cinch::Plugins::Login] = { :password => options[:password] }
  end

  on :message, '!help' do |m|
    m.bot.plugins.each { |plugin|
      plugin.handlers.each { |handler|
        pattern = handler.pattern
        name    = plugin.to_s.split('::')[1].split(?:)[0]

        prefix = case pattern.prefix
          when Regexp then pattern.prefix.source
          when String then pattern.prefix
          else            ''
        end

        suffix = case pattern.suffix
          when Regexp then pattern.suffix.source
          when String then pattern.suffix
          else             ''
        end

        regex = case pattern.pattern
          when Regexp then pattern.pattern.source
          when String then pattern.pattern
          else             ''
        end

        m.reply regex.empty? ? name : "#{name}: #{prefix}#{regex}#{suffix}"
      }
    }
  end

  on :message, '!è' do |m|
    m.reply ?È
  end

  on :message, '!t' do |m|
    m.reply ?~
  end

  on :message, '!"' do |m|
    m.reply '“…”'
  end

  on :message, '!version' do |m|
    m.reply Descartes.version
  end
}.start
